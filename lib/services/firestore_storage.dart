import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:ocassetmanagement/models/building_model.dart';
import 'package:ocassetmanagement/models/maintenance_log.dart';
import 'package:ocassetmanagement/models/misc_model.dart';
import 'package:ocassetmanagement/models/permissions_model.dart';
import 'package:ocassetmanagement/models/person_model.dart';
import 'package:ocassetmanagement/models/room_model.dart';
import 'package:ocassetmanagement/models/user_group_model.dart';
import 'package:ocassetmanagement/models/user_model.dart';
import 'package:ocassetmanagement/models/vendor_model.dart';
import '/models/asset_instance.dart';
import '/models/asset_model.dart';

class FirestoreStorage {
  static const _users = 'Users';
  static const _assets = 'Asset';
  static const _people = 'People';
  static const _buildings = 'Buildings';
  static const _rooms = 'Rooms';

  static const _vendors = 'Vendors';
  static const _userGroups = 'UserGroups';
  static const _miscellaneous = 'Miscellaneous';
  static const _permissions = 'Permissions';
  static const _maintenanceLogs = 'MaintenanceLogs';
  final db = FirebaseFirestore.instance;
  List<String> ug = [];
  Permission userPerms = Permission();

  static final FirestoreStorage _singleton = FirestoreStorage._internal();

  factory FirestoreStorage() {
    return _singleton;
  }

  FirestoreStorage._internal();

  Future<int> getValue() async {
    final doc = await db.collection('temp').doc('temp').get();
    return doc.get('num') ?? 0;
  }

  // All Firestore methods for 'Vendors'

  Future<List<Vendor>> getVendors() async {
    final snapshot = await db.collection(_vendors).get();

    return snapshot.docs.map((doc) => Vendor.fromFirestore(doc)).toList();
  }

  Future<void> updateVendor(String vendorId, Map<String, dynamic> data) async {
    await db.collection(_vendors).doc(vendorId).update(data);
  }

  Future<void> insertVendor(Vendor vendor) {
    return db.collection(_vendors).doc(vendor.vendorId).set({
      'vendorId': vendor.vendorId,
      'type': vendor.type,
      'name': vendor.name,
    });
  }

  // All Firestore methods for 'Asset' (Asset Instances)

  Future<AssetInstance> getAsset(int serialNum) async {
    AssetInstance asset = AssetInstance();

    QuerySnapshot<Map<String, dynamic>> event =
        await db.collection(_assets).where(serialNum).get();

    for (var doc in event.docs) {
      final data = doc.data();

      asset.description = data['description'];
      asset.serialNum = doc.data()['serialNum'];
      asset.wirelessNIC = doc.data()['wirelessNIC'];
    }

    return asset;
  }

// TODO: Needs to be expanded to account for assets whose unique identifier is something other than a serial number (e.g. key)
  Future<bool> assetExists(var assetIdentifier) async {
    bool assetExists = false;
    await db
        .collection(_assets)
        .where('serialNum', isEqualTo: assetIdentifier)
        .get()
        .then((querySnapshot) {
      if (querySnapshot.docs.isNotEmpty) {
        assetExists = true;
      }
    });

    return assetExists;
  }

  // Future<void> insertAssetInstance(AssetInstance asset) {
  //   return db.collection(_assets).doc().set({
  //     'id': "33",
  //     'assetProfileId': 2,
  //     'assetCategoryId': 5,
  //     'description': asset.description,
  //     'serialNum': asset.serialNum,
  //     'status': 'In Inventory',
  //     'wirelessNIC': asset.wirelessNIC,
  //     'internalFeatures': 'Mhm',
  //     'externalAccessories': 'Wireless G502'
  //   });
  // }

  Future<void> insertAsset(Asset asset) async {
    DocumentReference docRef = await db.collection(_assets).add(asset.toMap());

    String autoGeneratedId = docRef.id;

    return await db.collection(_assets).doc(autoGeneratedId).update({
      'id': autoGeneratedId,
    });
  }

// Get all asset instances
  Future<List<Asset>> getAssets() async {
    final snapshot = await db.collection(_assets).get();
    return snapshot.docs.map((doc) => Asset.fromFirestore(doc)).toList();
  }

  // Get all asset types as DropdownMenuItems.
  Future<List<DropdownMenuItem>> getAssetTypes() async {
    QuerySnapshot<Map<String, dynamic>> event =
        await db.collection('AssetTypes').get();

    List<DropdownMenuItem> menuItems = [];
    menuItems.add(DropdownMenuItem(value: '', child: Text('')));

    for (var doc in event.docs) {
      final data = doc.data();
      var newItem =
          DropdownMenuItem(value: data['name'], child: Text(data['name']));

      menuItems.add(newItem);
    }

    return menuItems;
  }

// Get all people
  Future<List<Person>> getPeople() async {
    final snapshot = await db.collection(_people).get();
    return snapshot.docs.map((doc) => Person.fromFirestore(doc)).toList();
  }

//  Buildings
  Future<List<Building>> getBuildings() async {
    final snapshot = await db.collection(_buildings).get();
    return snapshot.docs.map<Building>((doc) {
      return Building.fromFirestore(doc);
    }).toList();
  }

  Future<void> updateBuilding(Building building) async {
    await db.collection(_buildings).doc(building.id).update(building.toMap());
  }

// Get all rooms
  Future<List<Room>> getRooms() async {
    final snapshot = await db.collection(_rooms).get();
    return snapshot.docs.map((doc) => Room.fromFirestore(doc)).toList();
  }

// Get all the names of rooms for a certain building.
  Future<List<dynamic>> getRoomsForBuilding(String buildingName) async {
    List<dynamic> rooms = [];

    QuerySnapshot<Map<String, dynamic>> event =
        await db.collection('Buildings').get();

    for (var doc in event.docs) {
      if (doc.data()['name'] == buildingName) {
        final data = doc.data();
        rooms = data['rooms'];
      }
    }

    return rooms;
  }

  Future<List<DropdownMenuItem>> getPeopleAsDropdownMenuItems() async {
    var people = await getPeople();
    List<DropdownMenuItem> menuItems = [];
    // ignore: prefer_const_constructors
    menuItems.add(DropdownMenuItem(value: '', child: Text('')));
    for (Person person in people) {
      var newItem = DropdownMenuItem(
          value: '${person.name} ${person.schoolId}',
          child: Text('${person.name} ${person.schoolId}'));

      menuItems.add(newItem);
    }
    return menuItems;
  }

  Future<List<DropdownMenuItem>> getBuildingsAsDropdownMenuItems() async {
    var buildings = await getBuildings();
    List<DropdownMenuItem> menuItems = [];
    // ignore: prefer_const_constructors
    menuItems.add(DropdownMenuItem(value: '', child: Text('')));
    for (Building building in buildings) {
      var newItem =
          DropdownMenuItem(value: building.name, child: Text(building.name));

      menuItems.add(newItem);
    }
    return menuItems;
  }

  Future<List<DropdownMenuItem>> getRoomsForBuildingAsDropdownMenuItems(
      String buildingName) async {
    List<dynamic> rooms = await getRoomsForBuilding(buildingName);
    List<DropdownMenuItem> menuItems = [];
    // ignore: prefer_const_constructors
    menuItems.add(DropdownMenuItem(value: '', child: Text('')));
    for (String room in rooms) {
      var newItem = DropdownMenuItem(value: room, child: Text(room));

      menuItems.add(newItem);
    }
    return menuItems;
  }

  Future<void> removeAssetInstance(Asset asset) async {
    db.collection(_assets).doc(asset.id).delete();
  }

  Future<void> updateAsset(String assetId, Map<String, dynamic> data) async {
    return await db.collection(_assets).doc(assetId).update(data);
  }

  // All Firestore Functions for 'Users'

  Future<bool> userExists(String userId) async {
    bool userExists = false;
    final users = await db
        .collection("Users")
        .where("userId", isEqualTo: userId)
        .count()
        .get();
    if (users.count! > 0) {
      userExists = true;
    }

    return userExists;
  }

  Future<bool> userExistsWithEmail(String email) async {
    bool userExists = false;
    final users = await db
        .collection("Users")
        .where("email", isEqualTo: email)
        .count()
        .get();
    if (users.count! > 0) {
      userExists = true;
    }

    return userExists;
  }

  Future<User> getUser(String userId) async {
    User user = User();

    QuerySnapshot<Map<String, dynamic>> event =
        await db.collection(_users).get();

    for (var doc in event.docs) {
      if (doc.data()['userId'] == userId) {
        final data = doc.data();

        user.email = data['email'];
        user.name = doc.data()['name'];
        user.schoolId = doc.data()['schoolId'];
        user.userGroup = doc.data()['userGroup'];
        user.userId = doc.data()['userId'];
      }
    }

    return user;
  }

  Future<void> insertUser(User user) {
    return db.collection(_users).doc(user.userId).set({
      'userId': user.userId,
      'email': user.email,
      'name': user.name,
      'schoolId': user.schoolId,
      'userGroup': user.userGroup,
    });
  }

  Future<void> addNewUser(User user) async {
    DocumentReference docRef = await db.collection(_users).add(user.toMap());

    String autoGeneratedId = docRef.id;

    return await db.collection(_users).doc(autoGeneratedId).update({
      'userId': autoGeneratedId,
    });
  }

  Future<void> insertPerson(Person person) {
    return db.collection('People').doc().set({
      'email': person.email,
      'name': person.name,
      'schoolId': person.schoolId,
    });
  }

  Future<void> assignAsset(int assetSerial, int? personSchoolID,
      String buildingName, String roomName, String returnDate) async {
    // TODO: Check to see if asset exists (only based on serial number right now).
    // Needs to be expanded to deal with asset identifiers of other types, such as keys (e.g. keyNumber).
    bool validAsset = await assetExists(assetSerial);

    // Add new document to Assignments collection if asset identifier (serial number, keyNumber, etc.) matches an asset in the system.
    if (validAsset) {
      return db.collection('Assignments').doc().set({
        'assetSerial': assetSerial,
        'personSchoolID': personSchoolID,
        'building': buildingName,
        'room': roomName,
        'assignedDate': DateTime.now().toString().split(" ")[0],
        'returnDate': returnDate,
      });
    } else {
      // TODO: Throw error of invalid asset identifier.
      throw Exception('No asset with specified identifier exists');
    }
  }

  Future<void> updateUser(User user) async {
    await db.collection(_users).doc(user.userId).update(user.toMap());
  }

  Future<List<User>> getUsers() async {
    final snapshot = await db.collection(_users).get();

    return snapshot.docs.map((doc) => User.fromFirestore(doc)).toList();
  }

  // All methods for 'UserGroups' in Firebase

  Future<List<UserGroup>> getUserGroups() async {
    final snapshot = await db.collection(_userGroups).get();

    return snapshot.docs.map((doc) => UserGroup.fromFirestore(doc)).toList();
  }

  Future<List<Misc>> getUserG() async {
    final event =
        await db.collection(_miscellaneous).doc('miscellaneous').get();

    return event
        .data()?['UserGroup']
        .map<Misc>((userGroup) => Misc(name: userGroup))
        .toList();
  }

  Future<void> insertUserGroup(UserGroup userGroup) {
    ug.add(userGroup.name);
    return db.collection(_miscellaneous).doc('miscellaneous').set({
      'UserGroup': FieldValue.arrayUnion(ug),
    });
  }

  Future<void> updateUserGroup(String group) async {
    final newGroup = <String, dynamic>{
      'UserGroup': group,
    };
    await db.collection(_miscellaneous).doc('miscellaneous').update(newGroup);
  }

  Future<void> removeUserGroup(String group) async {
    List<String> removeName = [];
    removeName.add(group);
    return db.collection(_miscellaneous).doc('miscellaneous').set({
      'UserGroup': FieldValue.arrayRemove(removeName),
    });
  }

  // Miscellaneous Load

  Future<void> loadMisc() async {
    final event =
        await db.collection(_miscellaneous).doc('miscellaneous').get();

    ug = event
        .data()?['UserGroup']
        .map<String>((userGroup) => userGroup.toString())
        .toList();
  }

  // Permissions
  Future<void> editPermissions(String? userGroup, Permission permission) {
    return db
        .collection(_permissions)
        .doc(userGroup)
        .set(permission.toMap(permission));
  }

  Future<Permission> getPermissions(String userGroup) async {
    DocumentSnapshot<Map<String, dynamic>> event =
        await db.collection(_permissions).doc(userGroup).get();
    return Permission.fromFirestore(event);
  }

  Future<void> loadPermissions(String? userGroup) async {
    DocumentSnapshot<Map<String, dynamic>> event =
        await db.collection(_permissions).doc(userGroup).get();
    userPerms = Permission.fromFirestore(event);
  }

  // Future<Permission> getUserPermission() async {
  //   print("Enter Get");
  //   print(userPerms.accessMaint);
  //   print(userPerms.reportGen);
  //   return userPerms;
  // }

  Permission getUserPermission() {
    return userPerms;
  }

  // Asset maintenance logs

  Future<void> insertMaintenanceLog(Asset asset, MaintenanceLog log) async {
    DocumentReference docRef = await db
        .collection(_assets)
        .doc(asset.id)
        .collection(_maintenanceLogs)
        .add(log.toMap());

    String autoGeneratedId = docRef.id;

    return await db
        .collection(_assets)
        .doc(asset.id)
        .collection(_maintenanceLogs)
        .doc(autoGeneratedId)
        .update({
      'logId': autoGeneratedId,
    });
  }

  Future<List<MaintenanceLog>> getMaintenanceLogs(Asset asset) async {
    final snapshot = await db
        .collection(_assets)
        .doc(asset.id)
        .collection(_maintenanceLogs)
        .get();

    return snapshot.docs
        .map((doc) => MaintenanceLog.fromFirestore(doc))
        .toList();
  }

  Future<void> updateMaintenanceLog(Asset asset, MaintenanceLog log) async {
    await db
        .collection(_assets)
        .doc(asset.id)
        .collection(_maintenanceLogs)
        .doc(log.logId)
        .update(log.toMap());
  }

  Future<void> removeMaintenanceLog(Asset asset, MaintenanceLog log) async {
    return db
        .collection(_assets)
        .doc(asset.id)
        .collection(_maintenanceLogs)
        .doc(log.logId)
        .delete();
  }
}
